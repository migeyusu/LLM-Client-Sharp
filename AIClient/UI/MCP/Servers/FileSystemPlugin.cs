// -------------------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a .Net Development Expert.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// -------------------------------------------------------------------------------------------------

using System.ComponentModel;
using System.IO;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using DiffPlex;
using DiffPlex.DiffBuilder;
using DiffPlex.DiffBuilder.Model;
using LLMClient.UI.MCP.Servers;
using Microsoft.Extensions.FileSystemGlobbing;
using Microsoft.SemanticKernel;

/// <summary>
/// A Kernel Plugin for interacting with the local file system in a secure manner.
/// It provides functions for reading, writing, editing, and managing files and directories
/// within a set of allowed directories.
/// </summary>
public class FileSystemPlugin
{
    private readonly IReadOnlyList<string> _allowedDirectories;
    private readonly string _userHomeDirectory = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

    /// <summary>
    /// Initializes a new instance of the <see cref="FileSystemPlugin"/> class.
    /// </summary>
    /// <param name="allowedPaths">A list of absolute paths that the plugin is allowed to access.</param>
    /// <exception cref="ArgumentException">Thrown if any of the allowed paths are invalid, not absolute, or do not exist.</exception>
    public FileSystemPlugin(IEnumerable<string> allowedPaths)
    {
        _allowedDirectories = allowedPaths
            .Select(ExpandAndNormalizePath)
            .Where(p => !string.IsNullOrWhiteSpace(p))
            .ToList()
            .AsReadOnly();

        if (_allowedDirectories.Count == 0)
        {
            throw new ArgumentException("At least one allowed directory must be provided.", nameof(allowedPaths));
        }

        // Validate that all configured directories exist.
        foreach (var dir in _allowedDirectories)
        {
            if (!Directory.Exists(dir))
            {
                throw new ArgumentException($"The configured allowed directory does not exist: {dir}", nameof(allowedPaths));
            }
        }
    }

    [KernelFunction, Description("Returns the list of directories that this server is allowed to access. " +
                                 "Use this to understand which directories are available before trying to access files.")]
    public string ListAllowedDirectories()
    {
        return $"Allowed directories:\n{string.Join('\n', _allowedDirectories)}";
    }

    [KernelFunction, Description("Read the complete contents of a file from the file system. Handles various text encodings and provides detailed error messages if the file cannot be read. Use this tool when you need to examine the contents of a single file. Use the 'head' parameter to read only the first N lines of a file, or the 'tail' parameter to read only the last N lines of a file. Only works within allowed directories.")]
    public async Task<string> ReadFileAsync(
        [Description("The path to the file to read.")] string path,
        [Description("Optional: If provided, returns only the first N lines of the file.")] int? head = null,
        [Description("Optional: If provided, returns only the last N lines of the file.")] int? tail = null)
    {
        if (head.HasValue && tail.HasValue)
        {
            throw new ArgumentException("Cannot specify both 'head' and 'tail' parameters simultaneously.");
        }

        var fullPath = await ValidateAndResolvePathAsync(path);
        
        if (head.HasValue)
        {
            return await HeadFileAsync(fullPath, head.Value);
        }

        if (tail.HasValue)
        {
            return await TailFileAsync(fullPath, tail.Value);
        }

        return await File.ReadAllTextAsync(fullPath);
    }
    
    [KernelFunction, Description("Read the contents of multiple files simultaneously. " +
                                 "This is more efficient than reading files one by one when you need to analyze "+
                                 "or compare multiple files. Each file's content is returned with its " +
                                "path as a reference. Failed reads for individual files won't stop " +
                                "the entire operation. Only works within allowed directories.")]
    public async Task<string> ReadMultipleFilesAsync(
        [Description("The list of file paths to read.")] List<string> paths)
    {
        var results = new StringBuilder();
        foreach (var path in paths)
        {
            try
            {
                var fullPath = await ValidateAndResolvePathAsync(path);
                var content = await File.ReadAllTextAsync(fullPath);
                results.AppendLine($"{path}:\n{content}\n---");
            }
            catch (Exception e)
            {
                results.AppendLine($"{path}: Error - {e.Message}\n---");
            }
        }
        return results.ToString().TrimEnd('-', '\n', '\r');
    }

    [KernelFunction, Description( "Create a new file or completely overwrite an existing file with new content. " +
                                  "Use with caution as it will overwrite existing files without warning. " +
                                  "Handles text content with proper encoding. Only works within allowed directories.")]
    public async Task<string> WriteFileAsync(
        [Description("The path of the file to write to.")] string path,
        [Description("The content to write into the file.")] string content)
    {
        // For writing, we validate the parent directory of the target path.
        var fullPath = await ValidateAndResolvePathAsync(path, checkParentOnly: true);
        await File.WriteAllTextAsync(fullPath, content);
        return $"Successfully wrote to {path}";
    }

    [KernelFunction, Description( "Make line-based edits to a text file. Each edit replaces exact line sequences " +
                                  "with new content. Returns a git-style diff showing the changes made. " +
                                  "Only works within allowed directories.")]
    public async Task<string> EditFileAsync(
        [Description("The path of the file to edit.")] string path,
        [Description("A list of edit operations to perform on the file.")] List<EditOperation> edits,
        [Description("If true, previews changes in a diff format without saving them.")] bool dryRun = false)
    {
        var fullPath = await ValidateAndResolvePathAsync(path);
        var originalContent = await File.ReadAllTextAsync(fullPath);

        // Normalize line endings for consistent processing
        var workingContent = originalContent.Replace("\r\n", "\n");

        foreach (var edit in edits)
        {
            var oldTextNormalized = edit.OldText.Replace("\r\n", "\n");
            var newTextNormalized = edit.NewText.Replace("\r\n", "\n");

            if (!workingContent.Contains(oldTextNormalized))
            {
                // Fallback for whitespace differences, as in the original TS code.
                // This is a simplified version. A more robust implementation might use a fuzzy search.
                var oldLines = oldTextNormalized.Split('\n').Select(l => l.Trim()).ToArray();
                var contentLines = workingContent.Split('\n');
                var found = false;
                for (int i = 0; i <= contentLines.Length - oldLines.Length; i++)
                {
                    var slice = contentLines.Skip(i).Take(oldLines.Length).Select(l => l.Trim()).ToArray();
                    if (slice.SequenceEqual(oldLines))
                    {
                        var replacement = string.Join("\n", contentLines.Take(i)) + "\n" +
                                          newTextNormalized + "\n" +
                                          string.Join("\n", contentLines.Skip(i + oldLines.Length));
                        workingContent = replacement.Trim();
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    throw new InvalidOperationException($"Could not find the exact text to replace for the edit: {edit.OldText}");
                }
            }
            else
            {
                workingContent = workingContent.Replace(oldTextNormalized, newTextNormalized);
            }
        }
        
        var diffBuilder = new InlineDiffBuilder(new Differ());
        var diff = diffBuilder.BuildDiffModel(originalContent, workingContent);

        var diffReport = new StringBuilder();
        diffReport.AppendLine($"```diff");
        foreach (var line in diff.Lines)
        {
            switch (line.Type)
            {
                case ChangeType.Inserted:
                    diffReport.AppendLine($"+ {line.Text}");
                    break;
                case ChangeType.Deleted:
                    diffReport.AppendLine($"- {line.Text}");
                    break;
                case ChangeType.Unchanged:
                    diffReport.AppendLine($"  {line.Text}");
                    break;
            }
        }
        diffReport.AppendLine("```");

        if (!dryRun)
        {
            await File.WriteAllTextAsync(fullPath, workingContent);
            diffReport.AppendLine($"\nFile '{path}' has been updated.");
        }
        else
        {
            diffReport.AppendLine($"\nDry run: File '{path}' was not modified.");
        }

        return diffReport.ToString();
    }

    [KernelFunction, Description("Create a new directory or ensure a directory exists. Can create multiple " +
                                 "nested directories in one operation. If the directory already exists, " +
                                 "this operation will succeed silently. Perfect for setting up directory " +
                                 "structures for projects or ensuring required paths exist. Only works within allowed directories.")]
    public async Task<string> CreateDirectoryAsync(
        [Description("The path of the directory to create.")] string path)
    {
        var fullPath = await ValidateAndResolvePathAsync(path, checkParentOnly: true);
        Directory.CreateDirectory(fullPath);
        return $"Successfully created directory {path}";
    }

    [KernelFunction, Description("Get a detailed listing of all files and directories in a specified path. " +
                                 "Results clearly distinguish between files and directories with [FILE] and [DIR] " +
                                 "prefixes. This tool is essential for understanding directory structure and " +
                                 "finding specific files within a directory. Only works within allowed directories.")]
    public async Task<string> ListDirectoryAsync(
        [Description("The path of the directory to list.")] string path)
    {
        var fullPath = await ValidateAndResolvePathAsync(path);
        var entries = Directory.EnumerateFileSystemEntries(fullPath);
        
        var formatted = entries.Select(entry =>
        {
            var entryInfo = new FileInfo(entry); // Works for both files and dirs
            bool isDirectory = (entryInfo.Attributes & FileAttributes.Directory) == FileAttributes.Directory;
            return $"{(isDirectory ? "[DIR]" : "[FILE]")} {Path.GetFileName(entry)}";
        });
        
        return string.Join("\n", formatted);
    }
    
    [KernelFunction, Description("Get a detailed listing of all files and directories in a specified path, including sizes. " +
                                 "Results clearly distinguish between files and directories with [FILE] and [DIR] " +
                                 "prefixes. This tool is useful for understanding directory structure and " +
                                 "finding specific files within a directory. Only works within allowed directories.")]
    public async Task<string> ListDirectoryWithSizesAsync(
        [Description("The path of the directory to list.")] string path, 
        [Description("Sort entries by 'name' or 'size'.")] string sortBy = "name")
    {
        var fullPath = await ValidateAndResolvePathAsync(path);
        var directoryInfo = new DirectoryInfo(fullPath);
        var entries = directoryInfo.EnumerateFileSystemInfos();

        var detailedEntries = entries.Select(e => new
        {
            Name = e.Name,
            IsDirectory = e is DirectoryInfo,
            Size = (e as FileInfo)?.Length ?? 0,
            LastModified = e.LastWriteTime
        }).ToList();
        
        // Sorting logic
        var sortedEntries = sortBy.ToLowerInvariant() switch
        {
            "size" => detailedEntries.OrderByDescending(e => e.Size).ToList(),
            _ => detailedEntries.OrderBy(e => e.Name).ToList()
        };

        var report = new StringBuilder();
        foreach (var entry in sortedEntries)
        {
            var type = entry.IsDirectory ? "[DIR]" : "[FILE]";
            var size = entry.IsDirectory ? "" : FormatSize(entry.Size).PadLeft(10);
            report.AppendLine($"{type} {entry.Name,-30} {size}");
        }
        
        // Summary
        var totalFiles = detailedEntries.Count(e => !e.IsDirectory);
        var totalDirs = detailedEntries.Count(e => e.IsDirectory);
        var totalSize = detailedEntries.Sum(e => e.Size);
        
        report.AppendLine();
        report.AppendLine($"Total: {totalFiles} files, {totalDirs} directories");
        report.AppendLine($"Combined size: {FormatSize(totalSize)}");

        return report.ToString();
    }
    
    [KernelFunction, Description("Get a recursive tree view of files and directories as a JSON structure. " +
                                 "Each entry includes 'name', 'type' (file/directory), and 'children' for directories. " +
                                 "Files have no children array, while directories always have a children array (which may be empty). " +
                                 "The output is formatted with 2-space indentation for readability. Only works within allowed directories.")]
    public async Task<string> GetDirectoryTreeAsync(
        [Description("The root path to generate the tree from.")] string path)
    {
        var fullPath = await ValidateAndResolvePathAsync(path);
        var rootEntry = await BuildTreeAsync(new DirectoryInfo(fullPath));
        return JsonSerializer.Serialize(rootEntry, new JsonSerializerOptions { WriteIndented = true });
    }

    [KernelFunction, Description("Move or rename files and directories. Can move files between directories " +
                                 "and rename them in a single operation. If the destination exists, the " +
                                 "operation will fail. Works across different directories and can be used " +
                                 "for simple renaming within the same directory. Both source and destination must be within allowed directories.")]
    public async Task<string> MoveFileAsync(
        [Description("The source path of the file or directory to move.")] string source,
        [Description("The destination path.")] string destination)
    {
        var validSource = await ValidateAndResolvePathAsync(source);
        var validDest = await ValidateAndResolvePathAsync(destination, checkParentOnly: true);

        if (File.Exists(validSource))
        {
            File.Move(validSource, validDest);
        }
        else if (Directory.Exists(validSource))
        {
            Directory.Move(validSource, validDest);
        }
        else
        {
            throw new FileNotFoundException("Source path does not exist or is not a file or directory.", source);
        }
        
        return $"Successfully moved {source} to {destination}";
    }

    [KernelFunction, Description("Recursively search for files and directories matching a pattern. " +
                                 "Searches through all subdirectories from the starting path. The search " +
                                 "is case-insensitive and matches partial names. Returns full paths to all " +
                                 "matching items. Great for finding files when you don't know their exact location. " +
                                 "Only searches within allowed directories.")]
    public async Task<string> SearchFilesAsync(
        [Description("The root path to start searching from.")] string path,
        [Description("The case-insensitive search pattern to match in file/directory names.")] string pattern,
        [Description("Optional list of glob patterns to exclude from the search (e.g., '**/bin', 'obj/**').")] List<string>? excludePatterns = null)
    {
        var fullPath = await ValidateAndResolvePathAsync(path);
        
        var matcher = new Matcher(StringComparison.OrdinalIgnoreCase);
        if (excludePatterns != null && excludePatterns.Count > 0)
        {
            matcher.AddExcludePatterns(excludePatterns);
        }
        
        var allFiles = Directory.EnumerateFileSystemEntries(fullPath, "*", SearchOption.AllDirectories);

        var results = new List<string>();
        foreach (var entry in allFiles)
        {
            // Check for exclusion
            if (matcher.Match(Path.GetRelativePath(fullPath, entry)).HasMatches)
            {
                continue;
            }

            // Check for pattern match (case-insensitive contains)
            if (Path.GetFileName(entry).Contains(pattern, StringComparison.OrdinalIgnoreCase))
            {
                results.Add(entry);
            }
        }

        return results.Count > 0 ? string.Join("\n", results) : "No matches found.";
    }

    [KernelFunction, Description("Retrieve detailed metadata about a file or directory. Returns comprehensive " +
                                 "information including size, creation time, last modified time, permissions, " +
                                 "and type. This tool is perfect for understanding file characteristics " +
                                 "without reading the actual content. Only works within allowed directories.")]
    public async Task<string> GetFileInfoAsync(
        [Description("The path to the file or directory.")] string path)
    {
        var fullPath = await ValidateAndResolvePathAsync(path);
        FileSystemInfo info = (File.GetAttributes(fullPath) & FileAttributes.Directory) == FileAttributes.Directory
            ? new DirectoryInfo(fullPath)
            : new FileInfo(fullPath);

        var sb = new StringBuilder();
        sb.AppendLine($"Name: {info.Name}");
        sb.AppendLine($"FullName: {info.FullName}");
        sb.AppendLine($"Type: {(info is DirectoryInfo ? "Directory" : "File")}");
        if (info is FileInfo fileInfo)
        {
            sb.AppendLine($"Size: {fileInfo.Length} bytes ({FormatSize(fileInfo.Length)})");
            sb.AppendLine($"IsReadOnly: {fileInfo.IsReadOnly}");
        }
        sb.AppendLine($"Created: {info.CreationTimeUtc:o}");
        sb.AppendLine($"LastModified: {info.LastWriteTimeUtc:o}");
        sb.AppendLine($"LastAccessed: {info.LastAccessTimeUtc:o}");
        return sb.ToString();
    }
    
    #region Helper DTOs

    /// <summary>
    /// Represents a single edit operation, replacing old text with new text.
    /// </summary>
    public class EditOperation
    {
        [JsonPropertyName("oldText")]
        [Description("The exact text to search for and replace.")]
        public string OldText { get; set; } = string.Empty;

        [JsonPropertyName("newText")]
        [Description("The new text that will replace the old text.")]
        public string NewText { get; set; } = string.Empty;
    }
    
    /// <summary>
    /// Represents an entry in a directory tree structure.
    /// </summary>
    public class TreeEntry
    {
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;
        
        [JsonPropertyName("type")]
        public string Type { get; set; } = "file";
        
        [JsonPropertyName("children")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public List<TreeEntry>? Children { get; set; }
    }

    #endregion
    
    #region Private Helper Methods

    private string ExpandAndNormalizePath(string path)
    {
        if (string.IsNullOrWhiteSpace(path)) return string.Empty;
        
        // Expand home directory symbol '~'
        if (path == "~" || path.StartsWith("~/"))
        {
            path = Path.Combine(_userHomeDirectory, path.Length > 1 ? path.Substring(2) : "");
        }
        
        // Return the fully qualified, normalized path.
        return Path.GetFullPath(path);
    }
    
    private async Task<string> ValidateAndResolvePathAsync(string requestedPath, bool checkParentOnly = false)
    {
        if (string.IsNullOrWhiteSpace(requestedPath))
        {
            throw new ArgumentException("Path cannot be null or empty.", nameof(requestedPath));
        }

        string absolutePath = ExpandAndNormalizePath(requestedPath);
        string pathToValidate = checkParentOnly ? Path.GetDirectoryName(absolutePath) ?? "" : absolutePath;

        if (string.IsNullOrEmpty(pathToValidate))
        {
            throw new UnauthorizedAccessException($"Cannot determine parent directory for path: {requestedPath}");
        }

        // 1. Check if the path is within one of the allowed directories.
        var isAllowed = _allowedDirectories.Any(dir => pathToValidate.StartsWith(dir, StringComparison.OrdinalIgnoreCase));
        if (!isAllowed)
        {
            throw new UnauthorizedAccessException($"Access denied. The path '{requestedPath}' is outside the allowed directories.");
        }

        // 2. Handle symbolic links to prevent escaping the allowed directories.
        // We check the real path of the final target.
        string realPath;
        try
        {
            // For existing files/directories, resolve the final physical path.
            realPath = new DirectoryInfo(pathToValidate).ResolveLinkTarget(true)?.FullName ?? pathToValidate;
        }
        catch (IOException) // Handles cases where path does not exist yet
        {
            // For new files/dirs, trust the absolute path after the initial check.
            realPath = pathToValidate;
        }

        var isRealPathAllowed = _allowedDirectories.Any(dir => realPath.StartsWith(dir, StringComparison.OrdinalIgnoreCase));
        if (!isRealPathAllowed)
        {
            throw new UnauthorizedAccessException("Access denied. The path or its symbolic link target is outside the allowed directories.");
        }

        // Return the original, non-resolved absolute path if validation passes.
        // This is crucial for creating new files in directories that might themselves be symlinks.
        return await Task.FromResult(absolutePath);
    }
    
    private static string FormatSize(long bytes)
    {
        if (bytes < 0) return "N/A";
        if (bytes == 0) return "0 B";
        
        string[] units = { "B", "KB", "MB", "GB", "TB", "PB" };
        int i = (int)Math.Floor(Math.Log(bytes) / Math.Log(1024));
        return $"{bytes / Math.Pow(1024, i):F2} {units[i]}";
    }
    
    private static async Task<string> HeadFileAsync(string path, int lineCount)
    {
        if (lineCount <= 0) return string.Empty;
        
        var lines = new List<string>(lineCount);
        using var reader = new StreamReader(path);
        for (int i = 0; i < lineCount; i++)
        {
            var line = await reader.ReadLineAsync();
            if (line == null) break;
            lines.Add(line);
        }
        return string.Join("\n", lines);
    }

    private static async Task<string> TailFileAsync(string path, int lineCount)
    {
        if (lineCount <= 0) return string.Empty;

        // This is a memory-efficient implementation for large files.
        using var fileStream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
        if (fileStream.Length == 0) return string.Empty;

        const int bufferSize = 4096;
        byte[] buffer = new byte[bufferSize];
        var lines = new List<string>();
        long position = fileStream.Length;

        while (position > 0 && lines.Count <= lineCount)
        {
            long readPosition = Math.Max(0, position - bufferSize);
            int bytesToRead = (int)(position - readPosition);
            fileStream.Position = readPosition;
            await fileStream.ReadAsync(buffer, 0, bytesToRead);

            var text = Encoding.UTF8.GetString(buffer, 0, bytesToRead);
            var textLines = text.Split('\n');
            
            // Prepend lines in reverse order
            for (int i = textLines.Length - 1; i >= 0; i--)
            {
                if (lines.Count > lineCount) break;
                lines.Insert(0, textLines[i]);
            }

            position = readPosition;
        }
        
        // Clean up partial lines and join result
        var resultLines = string.Join("\n", lines).Split('\n');
        return string.Join("\n", resultLines.TakeLast(lineCount));
    }
    
    private async Task<List<TreeEntry>> BuildTreeAsync(DirectoryInfo dirInfo)
    {
        var treeEntries = new List<TreeEntry>();
        foreach (var fileSystemInfo in dirInfo.EnumerateFileSystemInfos())
        {
            var treeEntry = new TreeEntry()
            {
                Name = fileSystemInfo.Name,
            };
            if (fileSystemInfo is DirectoryInfo directoryInfo)
            {
                treeEntry.Type="directory";
                treeEntry.Children = await BuildTreeAsync(directoryInfo);
            }
            else if (fileSystemInfo is FileInfo fileInfo)
            {
                treeEntry.Type="file";
            }
            // Security check for each subdirectory before recursing
            await ValidateAndResolvePathAsync(fileSystemInfo.FullName);
            treeEntries.Add(treeEntry);
        }
        
        return treeEntries;
    }
    
    #endregion
}